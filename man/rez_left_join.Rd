% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rezrDF_left_join.R
\name{rez_left_join}
\alias{rez_left_join}
\title{Perform a left join on two rez data.frames and change field access status.}
\usage{
rez_left_join(
  df1,
  df2 = NULL,
  ...,
  fieldaccess = "foreign",
  df2Address = "",
  fkey = "",
  rezrObj = NULL
)
}
\arguments{
\item{df1}{The left data.frame.}

\item{df2}{The right data.frame.}

\item{...}{Other functions passed onto left_join, i.e. the columns you will be changing or adding.}

\item{fieldaccess}{The field access status of the field you're addding, either a single character (to apply to all of the new fields) or a vector of characters for each new field. Note that if you are both modifying and adding fields, only the added fields will have access values changed. So if you're specifying an entire vector of field access values, the best practice in using this function is to separate new-field and added-field mutates, otherwise the code will be difficult to read.}

\item{df2Address}{The address to the source rezrDF.}

\item{fkey}{The foreign key to the df2. If not present, I'll guess with the by-line.}

\item{rezrObj}{The rezrObj object.}
}
\value{
resultDF
}
\description{
This is a wrapper for performing left joins on Rez data.frames. It \emph{only} changes the data frame, such as by changing field access data, at the moment. If your desired fieldaccess value is flex, this may serve as a drop-in replacement for mutate. Note that apart from the data.frame to be modified and the data.frame you are joining from, all arguments of left_join must be named.
By default, if no suffix is specified, the suffixes are c("", "_lower"). That is, if you are joining two data.frames, both with a column called 'name', then the left data.frame's column will still be called 'name' in the new data.frame but the right data.frame's column will get called 'name_lower'.
}
