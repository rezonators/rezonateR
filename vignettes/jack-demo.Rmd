---
title: "jack-demo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{jack-demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Preliminaries

Why you should use rezonateR
blah blah blah

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Import the library:

```{r setup}
library(rezonateR)
```

Import our first file:

```{r}
layerInfo = list(
  track = list(field = "name", regex = c("CLAUSEARG_", "DISCDEIX_"),
     names = c("clausearg", "discdeix", "refexpr")),
  chunk = list(field = "chunkLayer", regex = c("verb", "adv", "predadj"),
     names = c("verb", "adv", "predadj", "refexpr")))

myRez = importRez(system.file("extdata", "parting.rez", package = "rezonateR"), layerRegex = layerInfo)
```
# Introduction to rezrObjs and nodeMaps

Three main objects in rezonateR:
* rezrObj
* nodeMap
* rezrDF

One rezrObj contains one nodeMap and several rezrDFs:

```{r}
print("Item in myRez:")
names(myRez)
```

The nodeMap is like the Rezonator node-map, but organised into sub-categories:

```{r}
print("Items in the nodeMap:")
names(myRez$nodeMap)
```
Each element of the sub-category is a node:

```{r}
myRez$nodeMap$token[1:3] #Need to delete in the real vignette
``` 

# Introduction to rezrDFs

A rezrDF is like a normal data frame:

```{r}
head(myRez$unitDF)
```

chunkDF and trackDF are divided into layers (nodeMaps are NOT):

```{r}
print("Component DFs of chunkDF:")
names(myRez$chunkDF)
head(myRez$chunkDF$refexpr)
print("Component DFs of trackDF:")
names(myRez$trackDF)
```

rezrDFs have perks!

Perk 1: Field access labels prevents you from accidentally changing things

```{r}
print("fieldaccess:")
fieldaccess(myRez$unitDF)
```

```{r}
#myRez$tokenDF = myRez$tokenDF %>% rez_mutate(id = "wrong data")
#Trying to damage an ID field is not possible
```

Perk 2: Things get updated if you reload() them

```{r}
print("updateFunct of unitDF:")
updateFunct(myRez$unitDF)
```

```{r}
myRez$unitDF %>% filter(str_detect(word, "<0>")) %>% rez_select(id, word, wordWylie) 

#Change something in the token rezrDF that is significant for the unit rezrDF
myRez$tokenDF = myRez$tokenDF %>% rez_mutate(
  wordWylie = case_when(word == "<0>" ~ "<0>", T ~ wordWylie))
myRez$entryDF = myRez$entryDF %>% reload(myRez)
myRez$unitDF = myRez$unitDF %>% reload(myRez)

myRez$unitDF %>% filter(str_detect(word, "<0>")) %>% rez_select(id, word, wordWylie)
```

Perk 3: rezrDFs correspond to nodeMap elements

```{r}
print("inNodeMap:")
inNodeMap(myRez$unitDF)
```
This doesn't do so much yet, wait for the 1.0 release

# rezrDF operations

Three layers of rezrObj operations

1. EasyEdit: Easy even for base R users, less flexible (e.g. addField, changeFieldForeign)
2. TidyRez: Easy for tidyverse users, some learning curve for others (e.g. rez_mutate, rez_left_join)
3. Core engine: For more adventurous users who want maximum flexibility (e.g. lowerToUpper, createLeftJoinUpdate); called under the hood by EasyEdit and TidyRez

## EasyEdit

Adding a simple new field:

```{r}
myRez = addField(myRez, entity = "token", layer = "",
                 fieldName = "orthoLength",
                 expression = nchar(word),
                 fieldaccess = "auto")
viewCorePlus(myRez$tokenDF, c("word", "orthoLength"))
```

Adding a complex new field:

```{r}
myRez = addField(myRez, entity = "token", layer = "",
                 fieldName = "longestWordInUnit",
                 expression = longestLength(word),
                 type = "complex",
                 groupField = "unit",
                 fieldaccess = "auto")
viewCorePlus(myRez$tokenDF %>% arrange(unit, discourseTokenSeq), c("word", "longestWordInUnit"))
```


Adding a simple foreign field:

```{r}
myRez = addFieldForeign(myRez,
                targetEntity = "token", targetLayer = "",
                sourceEntity = "unit", sourceLayer = "",
                targetForeignKeyName = "unit",
                targetFieldName = "unitWord", sourceFieldName = "word",
                fieldaccess = "foreign")
viewCorePlus(myRez$tokenDF %>% arrange(unit, discourseTokenSeq), c("word", "unitWord"))
```

Adding a complex foreign field:

```{r}
myRez = addFieldForeign(myRez,
                targetEntity = "unit", targetLayer = "",
                sourceEntity = "entry", sourceLayer = "",
                targetForeignKeyName = "entryList",
                targetFieldName = "shortestWordLength",
                sourceFieldName = "word",
                type = "complex",
                complexAction = shortestLength,
                fieldaccess = "foreign")
viewCorePlus(myRez$unitDF %>% arrange(unitSeq), c("word", "shortestWordLength"))
```

## TidyRez
* Safe to use dplyr functions: filter, arrange, add_row, ...
* dplyr functions with TidyRez equivalents: rez_group_by, rez_group_split, rez_left_join, rez_mutate, rez_bind_rows, rez_rename, rez_select
* More planned: rez_bind_cols, rez_outer_join, etc.

TidyRez updates:
1. Field access status
2. Update functions (according to field access status and information input)

Using base R / classic dplyr may result in reload fails, unless supplemented with core engine functions

rez_select used on emancipated rezrDFs can still be updated:

```{r}
refTable = myRez$trackDF$refexpr %>% rez_select(id, token, chain, name, word, pred, tokenSeqLast)
print("Before:")
refTable$tokenSeqLast
refTable = refTable %>% mutate(tokenSeqLast = 1) #Damage refTable with a classic dplyr function
print("After:")
refTable = refTable %>% reload(myRez)
refTable$tokenSeqLast 
```

WARNING: TidyRez only updates THE CURRENT TABLE. If other tables have references to the table you're editing, they will not be updated. This is most important for rez_select and rez_rename. These functions should ONLY touch fields that are not used in other rezrDFs (again, unless you want to play with core engine functions).

# EasyTrack

Everyone loves accessibility, so you should spend less time on coding and more time on thinking and analysis!

Example 1: How many words/units away from the previous mention?

But first: set an isWord condition!
tokenSeq, discourseTokenSeq: Consider all tokens
wordSeq, discourseWordSeq: Consider only words

```{r}
myRez = addIsWordField(myRez, !str_detect(wordWylie, "/"))
myRez$trackDF$refexpr
```

Also: add unitSeq info (not added by default):

```{r}
myRez = addUnitSeq(myRez, "track")
```

Cool, we're good to go!

Units first:

```{r}
myRez$trackDF$refexpr = myRez$trackDF$refexpr %>%
  rez_mutate(unitsToLastMention = unitsToLastMention(unitSeqLast))
myRez$trackDF$refexpr
```

Then tokens:

```{r}
myRez$trackDF$refexpr =  myRez$trackDF$refexpr %>%
          rez_mutate(wordsToLastMention =
                             tokensToLastMention(discourseWordSeqLast, #What seq to use
                             zeroProtocol = "unitLast", #How to treat zeroes
                             zeroCond = (word == "<0>"),
                             unitDF = myRez$unitDF)) #Additional argument for unitLast protocol
myRez$trackDF$refexpr
```


Case 2: Counting previous and next mentions

Number of previous tokens in the last 5 units:

```{r}
myRez$trackDF$refexpr = myRez$trackDF$refexpr %>% rez_mutate(noPrevMentionsIn5 = noPrevMentions(5))
myRez$trackDF$refexpr
```

Number of zero mentions in any succeeding context:

```{r}
myRez$trackDF$refexpr = myRez$trackDF$refexpr %>% rez_mutate(noComingZeroes = noNextMentionsIf(Inf, word == "<0>"))
myRez$trackDF$refexpr
```

Case 3: Competitors

```{r}
myRez$trackDF$refexpr = myRez$trackDF$refexpr %>% rez_mutate(noCompetitors = noCompetitors())
myRez$trackDF$refexpr
```

Note: These functions have more complex forms for people who have changed the default column names.

More to come!

-unitFirst protocol -> initial / final
-no -> count
